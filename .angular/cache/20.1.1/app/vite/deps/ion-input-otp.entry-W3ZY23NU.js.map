{
  "version": 3,
  "sources": ["../../../../../../node_modules/@ionic/core/dist/esm/ion-input-otp.entry.js"],
  "sourcesContent": ["/*!\r\n * (C) Ionic http://ionicframework.com - MIT License\r\n */\r\nimport { r as registerInstance, d as createEvent, m as printIonWarning, e as getIonMode, h, F as Fragment, j as Host, k as getElement } from './index-B_U9CtaY.js';\r\nimport { i as inheritAriaAttributes } from './helpers-1O4D2b7y.js';\r\nimport { i as isRTL } from './dir-C53feagD.js';\r\nimport { c as createColorClasses } from './theme-DiVJyqlX.js';\r\n\r\nconst inputOtpIosCss = \".sc-ion-input-otp-ios-h{--margin-top:0;--margin-end:0;--margin-bottom:0;--margin-start:0;--padding-top:16px;--padding-end:0;--padding-bottom:16px;--padding-start:0;--color:initial;--min-width:40px;--separator-width:8px;--separator-height:var(--separator-width);--separator-border-radius:999px;--separator-color:var(--ion-color-step-150, var(--ion-background-color-step-150, #d9d9d9));--highlight-color-focused:var(--ion-color-primary, #0054e9);--highlight-color-valid:var(--ion-color-success, #2dd55b);--highlight-color-invalid:var(--ion-color-danger, #c5000f);--highlight-color:var(--highlight-color-focused);display:block;position:relative;font-size:0.875rem}.input-otp-group.sc-ion-input-otp-ios{-webkit-margin-start:var(--margin-start);margin-inline-start:var(--margin-start);-webkit-margin-end:var(--margin-end);margin-inline-end:var(--margin-end);margin-top:var(--margin-top);margin-bottom:var(--margin-bottom);-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center}.native-wrapper.sc-ion-input-otp-ios{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;min-width:var(--min-width)}.native-input.sc-ion-input-otp-ios{border-radius:var(--border-radius);width:var(--width);min-width:inherit;height:var(--height);border-width:var(--border-width);border-style:solid;border-color:var(--border-color);background:var(--background);color:var(--color);font-size:inherit;text-align:center;-webkit-appearance:none;-moz-appearance:none;appearance:none}.has-focus.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios{caret-color:var(--highlight-color)}.input-otp-description.sc-ion-input-otp-ios{color:var(--ion-color-step-700, var(--ion-text-color-step-300, #4d4d4d));font-size:0.75rem;line-height:1.25rem;text-align:center}.input-otp-description-hidden.sc-ion-input-otp-ios{display:none}.input-otp-separator.sc-ion-input-otp-ios{border-radius:var(--separator-border-radius);-ms-flex-negative:0;flex-shrink:0;width:var(--separator-width);height:var(--separator-height);background:var(--separator-color)}.input-otp-size-small.sc-ion-input-otp-ios-h{--width:40px;--height:40px}.input-otp-size-small.sc-ion-input-otp-ios-h .input-otp-group.sc-ion-input-otp-ios{gap:8px}.input-otp-size-medium.sc-ion-input-otp-ios-h{--width:48px;--height:48px}.input-otp-size-large.sc-ion-input-otp-ios-h{--width:56px;--height:56px}.input-otp-size-medium.sc-ion-input-otp-ios-h .input-otp-group.sc-ion-input-otp-ios,.input-otp-size-large.sc-ion-input-otp-ios-h .input-otp-group.sc-ion-input-otp-ios{gap:12px}.input-otp-shape-round.sc-ion-input-otp-ios-h{--border-radius:16px}.input-otp-shape-soft.sc-ion-input-otp-ios-h{--border-radius:8px}.input-otp-shape-rectangular.sc-ion-input-otp-ios-h{--border-radius:0}.input-otp-fill-outline.sc-ion-input-otp-ios-h{--background:none}.input-otp-fill-solid.sc-ion-input-otp-ios-h{--border-color:var(--ion-color-step-50, var(--ion-background-color-step-50, #f2f2f2));--background:var(--ion-color-step-50, var(--ion-background-color-step-50, #f2f2f2))}.input-otp-disabled.sc-ion-input-otp-ios-h{--color:var(--ion-color-step-350, var(--ion-text-color-step-650, #a6a6a6))}.input-otp-fill-outline.input-otp-disabled.sc-ion-input-otp-ios-h{--background:var(--ion-color-step-50, var(--ion-background-color-step-50, #f2f2f2));--border-color:var(--ion-color-step-100, var(--ion-background-color-step-100, #e6e6e6))}.input-otp-disabled.sc-ion-input-otp-ios-h,.input-otp-disabled.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios:disabled{cursor:not-allowed}.has-focus.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios:focus{--border-color:var(--highlight-color);outline:none}.input-otp-fill-outline.input-otp-readonly.sc-ion-input-otp-ios-h{--background:var(--ion-color-step-50, var(--ion-background-color-step-50, #f2f2f2))}.input-otp-fill-solid.input-otp-disabled.sc-ion-input-otp-ios-h,.input-otp-fill-solid.input-otp-readonly.sc-ion-input-otp-ios-h{--border-color:var(--ion-color-step-100, var(--ion-background-color-step-100, #e6e6e6));--background:var(--ion-color-step-100, var(--ion-background-color-step-100, #e6e6e6))}.ion-touched.ion-invalid.sc-ion-input-otp-ios-h{--highlight-color:var(--highlight-color-invalid)}.ion-valid.sc-ion-input-otp-ios-h{--highlight-color:var(--highlight-color-valid)}.has-focus.ion-valid.sc-ion-input-otp-ios-h,.ion-touched.ion-invalid.sc-ion-input-otp-ios-h{--border-color:var(--highlight-color)}.ion-color.sc-ion-input-otp-ios-h{--highlight-color-focused:var(--ion-color-base)}.input-otp-fill-outline.ion-color.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios,.input-otp-fill-solid.ion-color.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios:focus{border-color:rgba(var(--ion-color-base-rgb), 0.6)}.input-otp-fill-outline.ion-color.ion-invalid.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios,.input-otp-fill-solid.ion-color.ion-invalid.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios,.input-otp-fill-outline.ion-color.has-focus.ion-invalid.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios,.input-otp-fill-solid.ion-color.has-focus.ion-invalid.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios{border-color:var(--ion-color-danger, #c5000f)}.input-otp-fill-outline.ion-color.ion-valid.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios,.input-otp-fill-solid.ion-color.ion-valid.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios,.input-otp-fill-outline.ion-color.has-focus.ion-valid.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios,.input-otp-fill-solid.ion-color.has-focus.ion-valid.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios{border-color:var(--ion-color-success, #2dd55b)}.input-otp-fill-outline.input-otp-disabled.ion-color.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios{border-color:rgba(var(--ion-color-base-rgb), 0.3)}.sc-ion-input-otp-ios-h{--border-width:0.55px}.has-focus.sc-ion-input-otp-ios-h .native-input.sc-ion-input-otp-ios:focus{--border-width:1px}.input-otp-fill-outline.sc-ion-input-otp-ios-h{--border-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-250, var(--ion-background-color-step-250, #c8c7cc))))}\";\r\n\r\nconst inputOtpMdCss = \".sc-ion-input-otp-md-h{--margin-top:0;--margin-end:0;--margin-bottom:0;--margin-start:0;--padding-top:16px;--padding-end:0;--padding-bottom:16px;--padding-start:0;--color:initial;--min-width:40px;--separator-width:8px;--separator-height:var(--separator-width);--separator-border-radius:999px;--separator-color:var(--ion-color-step-150, var(--ion-background-color-step-150, #d9d9d9));--highlight-color-focused:var(--ion-color-primary, #0054e9);--highlight-color-valid:var(--ion-color-success, #2dd55b);--highlight-color-invalid:var(--ion-color-danger, #c5000f);--highlight-color:var(--highlight-color-focused);display:block;position:relative;font-size:0.875rem}.input-otp-group.sc-ion-input-otp-md{-webkit-margin-start:var(--margin-start);margin-inline-start:var(--margin-start);-webkit-margin-end:var(--margin-end);margin-inline-end:var(--margin-end);margin-top:var(--margin-top);margin-bottom:var(--margin-bottom);-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center}.native-wrapper.sc-ion-input-otp-md{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;min-width:var(--min-width)}.native-input.sc-ion-input-otp-md{border-radius:var(--border-radius);width:var(--width);min-width:inherit;height:var(--height);border-width:var(--border-width);border-style:solid;border-color:var(--border-color);background:var(--background);color:var(--color);font-size:inherit;text-align:center;-webkit-appearance:none;-moz-appearance:none;appearance:none}.has-focus.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md{caret-color:var(--highlight-color)}.input-otp-description.sc-ion-input-otp-md{color:var(--ion-color-step-700, var(--ion-text-color-step-300, #4d4d4d));font-size:0.75rem;line-height:1.25rem;text-align:center}.input-otp-description-hidden.sc-ion-input-otp-md{display:none}.input-otp-separator.sc-ion-input-otp-md{border-radius:var(--separator-border-radius);-ms-flex-negative:0;flex-shrink:0;width:var(--separator-width);height:var(--separator-height);background:var(--separator-color)}.input-otp-size-small.sc-ion-input-otp-md-h{--width:40px;--height:40px}.input-otp-size-small.sc-ion-input-otp-md-h .input-otp-group.sc-ion-input-otp-md{gap:8px}.input-otp-size-medium.sc-ion-input-otp-md-h{--width:48px;--height:48px}.input-otp-size-large.sc-ion-input-otp-md-h{--width:56px;--height:56px}.input-otp-size-medium.sc-ion-input-otp-md-h .input-otp-group.sc-ion-input-otp-md,.input-otp-size-large.sc-ion-input-otp-md-h .input-otp-group.sc-ion-input-otp-md{gap:12px}.input-otp-shape-round.sc-ion-input-otp-md-h{--border-radius:16px}.input-otp-shape-soft.sc-ion-input-otp-md-h{--border-radius:8px}.input-otp-shape-rectangular.sc-ion-input-otp-md-h{--border-radius:0}.input-otp-fill-outline.sc-ion-input-otp-md-h{--background:none}.input-otp-fill-solid.sc-ion-input-otp-md-h{--border-color:var(--ion-color-step-50, var(--ion-background-color-step-50, #f2f2f2));--background:var(--ion-color-step-50, var(--ion-background-color-step-50, #f2f2f2))}.input-otp-disabled.sc-ion-input-otp-md-h{--color:var(--ion-color-step-350, var(--ion-text-color-step-650, #a6a6a6))}.input-otp-fill-outline.input-otp-disabled.sc-ion-input-otp-md-h{--background:var(--ion-color-step-50, var(--ion-background-color-step-50, #f2f2f2));--border-color:var(--ion-color-step-100, var(--ion-background-color-step-100, #e6e6e6))}.input-otp-disabled.sc-ion-input-otp-md-h,.input-otp-disabled.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md:disabled{cursor:not-allowed}.has-focus.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md:focus{--border-color:var(--highlight-color);outline:none}.input-otp-fill-outline.input-otp-readonly.sc-ion-input-otp-md-h{--background:var(--ion-color-step-50, var(--ion-background-color-step-50, #f2f2f2))}.input-otp-fill-solid.input-otp-disabled.sc-ion-input-otp-md-h,.input-otp-fill-solid.input-otp-readonly.sc-ion-input-otp-md-h{--border-color:var(--ion-color-step-100, var(--ion-background-color-step-100, #e6e6e6));--background:var(--ion-color-step-100, var(--ion-background-color-step-100, #e6e6e6))}.ion-touched.ion-invalid.sc-ion-input-otp-md-h{--highlight-color:var(--highlight-color-invalid)}.ion-valid.sc-ion-input-otp-md-h{--highlight-color:var(--highlight-color-valid)}.has-focus.ion-valid.sc-ion-input-otp-md-h,.ion-touched.ion-invalid.sc-ion-input-otp-md-h{--border-color:var(--highlight-color)}.ion-color.sc-ion-input-otp-md-h{--highlight-color-focused:var(--ion-color-base)}.input-otp-fill-outline.ion-color.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md,.input-otp-fill-solid.ion-color.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md:focus{border-color:rgba(var(--ion-color-base-rgb), 0.6)}.input-otp-fill-outline.ion-color.ion-invalid.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md,.input-otp-fill-solid.ion-color.ion-invalid.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md,.input-otp-fill-outline.ion-color.has-focus.ion-invalid.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md,.input-otp-fill-solid.ion-color.has-focus.ion-invalid.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md{border-color:var(--ion-color-danger, #c5000f)}.input-otp-fill-outline.ion-color.ion-valid.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md,.input-otp-fill-solid.ion-color.ion-valid.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md,.input-otp-fill-outline.ion-color.has-focus.ion-valid.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md,.input-otp-fill-solid.ion-color.has-focus.ion-valid.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md{border-color:var(--ion-color-success, #2dd55b)}.input-otp-fill-outline.input-otp-disabled.ion-color.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md{border-color:rgba(var(--ion-color-base-rgb), 0.3)}.sc-ion-input-otp-md-h{--border-width:1px}.has-focus.sc-ion-input-otp-md-h .native-input.sc-ion-input-otp-md:focus{--border-width:2px}.input-otp-fill-outline.sc-ion-input-otp-md-h{--border-color:var(--ion-color-step-300, var(--ion-background-color-step-300, #b3b3b3))}\";\r\n\r\nconst InputOTP = class {\r\n    constructor(hostRef) {\r\n        registerInstance(this, hostRef);\r\n        this.ionInput = createEvent(this, \"ionInput\", 7);\r\n        this.ionChange = createEvent(this, \"ionChange\", 7);\r\n        this.ionComplete = createEvent(this, \"ionComplete\", 7);\r\n        this.ionBlur = createEvent(this, \"ionBlur\", 7);\r\n        this.ionFocus = createEvent(this, \"ionFocus\", 7);\r\n        this.inheritedAttributes = {};\r\n        this.inputRefs = [];\r\n        this.inputId = `ion-input-otp-${inputIds++}`;\r\n        this.parsedSeparators = [];\r\n        /**\r\n         * Tracks whether the user is navigating through input boxes using keyboard navigation\r\n         * (arrow keys, tab) versus mouse clicks. This is used to determine the appropriate\r\n         * focus behavior when an input box is focused.\r\n         */\r\n        this.isKeyboardNavigation = false;\r\n        this.inputValues = [];\r\n        this.hasFocus = false;\r\n        this.previousInputValues = [];\r\n        /**\r\n         * Indicates whether and how the text value should be automatically capitalized as it is entered/edited by the user.\r\n         * Available options: `\"off\"`, `\"none\"`, `\"on\"`, `\"sentences\"`, `\"words\"`, `\"characters\"`.\r\n         */\r\n        this.autocapitalize = 'off';\r\n        /**\r\n         * If `true`, the user cannot interact with the input.\r\n         */\r\n        this.disabled = false;\r\n        /**\r\n         * The fill for the input boxes. If `\"solid\"` the input boxes will have a background. If\r\n         * `\"outline\"` the input boxes will be transparent with a border.\r\n         */\r\n        this.fill = 'outline';\r\n        /**\r\n         * The number of input boxes to display.\r\n         */\r\n        this.length = 4;\r\n        /**\r\n         * If `true`, the user cannot modify the value.\r\n         */\r\n        this.readonly = false;\r\n        /**\r\n         * The shape of the input boxes.\r\n         * If \"round\" they will have an increased border radius.\r\n         * If \"rectangular\" they will have no border radius.\r\n         * If \"soft\" they will have a soft border radius.\r\n         */\r\n        this.shape = 'round';\r\n        /**\r\n         * The size of the input boxes.\r\n         */\r\n        this.size = 'medium';\r\n        /**\r\n         * The type of input allowed in the input boxes.\r\n         */\r\n        this.type = 'number';\r\n        /**\r\n         * The value of the input group.\r\n         */\r\n        this.value = '';\r\n        /**\r\n         * Handles the focus behavior for the input OTP component.\r\n         *\r\n         * Focus behavior:\r\n         * 1. Keyboard navigation: Allow normal focus movement\r\n         * 2. Mouse click:\r\n         *    - If clicked box has value: Focus that box\r\n         *    - If clicked box is empty: Focus first empty box\r\n         *\r\n         * Emits the `ionFocus` event when the input group gains focus.\r\n         */\r\n        this.onFocus = (index) => (event) => {\r\n            var _a;\r\n            const { inputRefs } = this;\r\n            // Only emit ionFocus and set the focusedValue when the\r\n            // component first gains focus\r\n            if (!this.hasFocus) {\r\n                this.ionFocus.emit(event);\r\n                this.focusedValue = this.value;\r\n            }\r\n            this.hasFocus = true;\r\n            let finalIndex = index;\r\n            if (!this.isKeyboardNavigation) {\r\n                // If the clicked box has a value, focus it\r\n                // Otherwise focus the first empty box\r\n                const targetIndex = this.inputValues[index] ? index : this.getFirstEmptyIndex();\r\n                finalIndex = targetIndex === -1 ? this.length - 1 : targetIndex;\r\n                // Focus the target box\r\n                (_a = this.inputRefs[finalIndex]) === null || _a === void 0 ? void 0 : _a.focus();\r\n            }\r\n            // Update tabIndexes to match the focused box\r\n            inputRefs.forEach((input, i) => {\r\n                input.tabIndex = i === finalIndex ? 0 : -1;\r\n            });\r\n            // Reset the keyboard navigation flag\r\n            this.isKeyboardNavigation = false;\r\n        };\r\n        /**\r\n         * Handles the blur behavior for the input OTP component.\r\n         * Emits the `ionBlur` event when the input group loses focus.\r\n         */\r\n        this.onBlur = (event) => {\r\n            const { inputRefs } = this;\r\n            const relatedTarget = event.relatedTarget;\r\n            // Do not emit blur if we're moving to another input box in the same component\r\n            const isInternalFocus = relatedTarget != null && inputRefs.includes(relatedTarget);\r\n            if (!isInternalFocus) {\r\n                this.hasFocus = false;\r\n                // Reset tabIndexes when focus leaves the component\r\n                this.updateTabIndexes();\r\n                // Always emit ionBlur when focus leaves the component\r\n                this.ionBlur.emit(event);\r\n                // Only emit ionChange if the value has actually changed\r\n                if (this.focusedValue !== this.value) {\r\n                    this.emitIonChange(event);\r\n                }\r\n            }\r\n        };\r\n        /**\r\n         * Handles keyboard navigation for the OTP component.\r\n         *\r\n         * Navigation:\r\n         * - Backspace: Clears current input and moves to previous box if empty\r\n         * - Arrow Left/Right: Moves focus between input boxes\r\n         * - Tab: Allows normal tab navigation between components\r\n         */\r\n        this.onKeyDown = (index) => (event) => {\r\n            const { length } = this;\r\n            const rtl = isRTL(this.el);\r\n            const input = event.target;\r\n            // Meta shortcuts are used to copy, paste, and select text\r\n            // We don't want to handle these keys here\r\n            const metaShortcuts = ['a', 'c', 'v', 'x', 'r', 'z', 'y'];\r\n            const isTextSelection = input.selectionStart !== input.selectionEnd;\r\n            // Return if the key is a meta shortcut or the input value\r\n            // text is selected and let the onPaste / onInput handler manage it\r\n            if (isTextSelection || ((event.metaKey || event.ctrlKey) && metaShortcuts.includes(event.key.toLowerCase()))) {\r\n                return;\r\n            }\r\n            if (event.key === 'Backspace') {\r\n                if (this.inputValues[index]) {\r\n                    // Shift all values to the right of the current index left by one\r\n                    for (let i = index; i < length - 1; i++) {\r\n                        this.inputValues[i] = this.inputValues[i + 1];\r\n                    }\r\n                    // Clear the last box\r\n                    this.inputValues[length - 1] = '';\r\n                    // Update all inputRefs to match inputValues\r\n                    for (let i = 0; i < length; i++) {\r\n                        this.inputRefs[i].value = this.inputValues[i] || '';\r\n                    }\r\n                    this.updateValue(event);\r\n                    event.preventDefault();\r\n                }\r\n                else if (!this.inputValues[index] && index > 0) {\r\n                    // If current input is empty, move to previous input\r\n                    this.focusPrevious(index);\r\n                }\r\n            }\r\n            else if (event.key === 'ArrowLeft' || event.key === 'ArrowRight') {\r\n                this.isKeyboardNavigation = true;\r\n                event.preventDefault();\r\n                const isLeft = event.key === 'ArrowLeft';\r\n                const shouldMoveNext = (isLeft && rtl) || (!isLeft && !rtl);\r\n                // Only allow moving to the next input if the current has a value\r\n                if (shouldMoveNext) {\r\n                    if (this.inputValues[index] && index < length - 1) {\r\n                        this.focusNext(index);\r\n                    }\r\n                }\r\n                else {\r\n                    this.focusPrevious(index);\r\n                }\r\n            }\r\n            else if (event.key === 'Tab') {\r\n                this.isKeyboardNavigation = true;\r\n                // Let all tab events proceed normally\r\n                return;\r\n            }\r\n        };\r\n        /**\r\n         * Processes all input scenarios for each input box.\r\n         *\r\n         * This function manages:\r\n         * 1. Autofill handling\r\n         * 2. Input validation\r\n         * 3. Full selection replacement or typing in an empty box\r\n         * 4. Inserting in the middle with available space (shifting)\r\n         * 5. Single character replacement\r\n         */\r\n        this.onInput = (index) => (event) => {\r\n            var _a, _b;\r\n            const { length, validKeyPattern } = this;\r\n            const input = event.target;\r\n            const value = input.value;\r\n            const previousValue = this.previousInputValues[index] || '';\r\n            // 1. Autofill handling\r\n            // If the length of the value increases by more than 1 from the previous\r\n            // value, treat this as autofill. This is to prevent the case where the\r\n            // user is typing a single character into an input box containing a value\r\n            // as that will trigger this function with a value length of 2 characters.\r\n            const isAutofill = value.length - previousValue.length > 1;\r\n            if (isAutofill) {\r\n                // Distribute valid characters across input boxes\r\n                const validChars = value\r\n                    .split('')\r\n                    .filter((char) => validKeyPattern.test(char))\r\n                    .slice(0, length);\r\n                // If there are no valid characters coming from the\r\n                // autofill, all input refs have to be cleared after the\r\n                // browser has finished the autofill behavior\r\n                if (validChars.length === 0) {\r\n                    requestAnimationFrame(() => {\r\n                        this.inputRefs.forEach((input) => {\r\n                            input.value = '';\r\n                        });\r\n                    });\r\n                }\r\n                for (let i = 0; i < length; i++) {\r\n                    this.inputValues[i] = validChars[i] || '';\r\n                    this.inputRefs[i].value = validChars[i] || '';\r\n                }\r\n                this.updateValue(event);\r\n                // Focus the first empty input box or the last input box if all boxes\r\n                // are filled after a small delay to ensure the input boxes have been\r\n                // updated before moving the focus\r\n                setTimeout(() => {\r\n                    var _a;\r\n                    const nextIndex = validChars.length < length ? validChars.length : length - 1;\r\n                    (_a = this.inputRefs[nextIndex]) === null || _a === void 0 ? void 0 : _a.focus();\r\n                }, 20);\r\n                this.previousInputValues = [...this.inputValues];\r\n                return;\r\n            }\r\n            // 2. Input validation\r\n            // If the character entered is invalid (does not match the pattern),\r\n            // restore the previous value and exit\r\n            if (value.length > 0 && !validKeyPattern.test(value[value.length - 1])) {\r\n                input.value = this.inputValues[index] || '';\r\n                this.previousInputValues = [...this.inputValues];\r\n                return;\r\n            }\r\n            // 3. Full selection replacement or typing in an empty box\r\n            // If the user selects all text in the input box and types, or if the\r\n            // input box is empty, replace only this input box. If the box is empty,\r\n            // move to the next box, otherwise stay focused on this box.\r\n            const isAllSelected = input.selectionStart === 0 && input.selectionEnd === value.length;\r\n            const isEmpty = !this.inputValues[index];\r\n            if (isAllSelected || isEmpty) {\r\n                this.inputValues[index] = value;\r\n                input.value = value;\r\n                this.updateValue(event);\r\n                this.focusNext(index);\r\n                this.previousInputValues = [...this.inputValues];\r\n                return;\r\n            }\r\n            // 4. Inserting in the middle with available space (shifting)\r\n            // If typing in a filled input box and there are empty boxes at the end,\r\n            // shift all values starting at the current box to the right, and insert\r\n            // the new character at the current box.\r\n            const hasAvailableBoxAtEnd = this.inputValues[this.inputValues.length - 1] === '';\r\n            if (this.inputValues[index] && hasAvailableBoxAtEnd && value.length === 2) {\r\n                // Get the inserted character (from event or by diffing value/previousValue)\r\n                let newChar = event.data;\r\n                if (!newChar) {\r\n                    newChar = value.split('').find((c, i) => c !== previousValue[i]) || value[value.length - 1];\r\n                }\r\n                // Validate the new character before shifting\r\n                if (!validKeyPattern.test(newChar)) {\r\n                    input.value = this.inputValues[index] || '';\r\n                    this.previousInputValues = [...this.inputValues];\r\n                    return;\r\n                }\r\n                // Shift values right from the end to the insertion point\r\n                for (let i = this.inputValues.length - 1; i > index; i--) {\r\n                    this.inputValues[i] = this.inputValues[i - 1];\r\n                    this.inputRefs[i].value = this.inputValues[i] || '';\r\n                }\r\n                this.inputValues[index] = newChar;\r\n                this.inputRefs[index].value = newChar;\r\n                this.updateValue(event);\r\n                this.previousInputValues = [...this.inputValues];\r\n                return;\r\n            }\r\n            // 5. Single character replacement\r\n            // Handles replacing a single character in a box containing a value based\r\n            // on the cursor position. We need the cursor position to determine which\r\n            // character was the last character typed. For example, if the user types \"2\"\r\n            // in an input box with the cursor at the beginning of the value of \"6\",\r\n            // the value will be \"26\", but we want to grab the \"2\" as the last character\r\n            // typed.\r\n            const cursorPos = (_a = input.selectionStart) !== null && _a !== void 0 ? _a : value.length;\r\n            const newCharIndex = cursorPos - 1;\r\n            const newChar = (_b = value[newCharIndex]) !== null && _b !== void 0 ? _b : value[0];\r\n            // Check if the new character is valid before updating the value\r\n            if (!validKeyPattern.test(newChar)) {\r\n                input.value = this.inputValues[index] || '';\r\n                this.previousInputValues = [...this.inputValues];\r\n                return;\r\n            }\r\n            this.inputValues[index] = newChar;\r\n            input.value = newChar;\r\n            this.updateValue(event);\r\n            this.previousInputValues = [...this.inputValues];\r\n        };\r\n        /**\r\n         * Handles pasting text into the input OTP component.\r\n         * This function prevents the default paste behavior and\r\n         * validates the pasted text against the allowed pattern.\r\n         * It then updates the value of the input group and focuses\r\n         * the next empty input after pasting.\r\n         */\r\n        this.onPaste = (event) => {\r\n            var _a, _b;\r\n            const { inputRefs, length, validKeyPattern } = this;\r\n            event.preventDefault();\r\n            const pastedText = (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData('text');\r\n            // If there is no pasted text, still emit the input change event\r\n            // because this is how the native input element behaves\r\n            // but return early because there is nothing to paste.\r\n            if (!pastedText) {\r\n                this.emitIonInput(event);\r\n                return;\r\n            }\r\n            const validChars = pastedText\r\n                .split('')\r\n                .filter((char) => validKeyPattern.test(char))\r\n                .slice(0, length);\r\n            // Always paste starting at the first box\r\n            validChars.forEach((char, index) => {\r\n                if (index < length) {\r\n                    this.inputRefs[index].value = char;\r\n                    this.inputValues[index] = char;\r\n                }\r\n            });\r\n            // Update the value so that all input boxes are updated\r\n            this.value = validChars.join('');\r\n            this.updateValue(event);\r\n            // Focus the next empty input after pasting\r\n            // If all boxes are filled, focus the last input\r\n            const nextEmptyIndex = validChars.length < length ? validChars.length : length - 1;\r\n            (_b = inputRefs[nextEmptyIndex]) === null || _b === void 0 ? void 0 : _b.focus();\r\n        };\r\n    }\r\n    /**\r\n     * Sets focus to an input box.\r\n     * @param index - The index of the input box to focus (0-based).\r\n     * If provided and the input box has a value, the input box at that index will be focused.\r\n     * Otherwise, the first empty input box or the last input if all are filled will be focused.\r\n     */\r\n    async setFocus(index) {\r\n        var _a, _b;\r\n        if (typeof index === 'number') {\r\n            const validIndex = Math.max(0, Math.min(index, this.length - 1));\r\n            (_a = this.inputRefs[validIndex]) === null || _a === void 0 ? void 0 : _a.focus();\r\n        }\r\n        else {\r\n            const tabbableIndex = this.getTabbableIndex();\r\n            (_b = this.inputRefs[tabbableIndex]) === null || _b === void 0 ? void 0 : _b.focus();\r\n        }\r\n    }\r\n    valueChanged() {\r\n        this.initializeValues();\r\n        this.updateTabIndexes();\r\n    }\r\n    /**\r\n     * Processes the separators prop into an array of numbers.\r\n     *\r\n     * If the separators prop is not provided, returns an empty array.\r\n     * If the separators prop is 'all', returns an array of all valid positions (1 to length-1).\r\n     * If the separators prop is an array, returns it as is.\r\n     * If the separators prop is a string, splits it by commas and parses each part as a number.\r\n     *\r\n     * If the separators are greater than the input length, it will warn and ignore the separators.\r\n     */\r\n    processSeparators() {\r\n        const { separators, length } = this;\r\n        if (separators === undefined) {\r\n            this.parsedSeparators = [];\r\n            return;\r\n        }\r\n        if (typeof separators === 'string' && separators !== 'all') {\r\n            const isValidFormat = /^(\\d+)(,\\d+)*$/.test(separators);\r\n            if (!isValidFormat) {\r\n                printIonWarning(`[ion-input-otp] - Invalid separators format. Expected a comma-separated list of numbers, an array of numbers, or \"all\". Received: ${separators}`, this.el);\r\n                this.parsedSeparators = [];\r\n                return;\r\n            }\r\n        }\r\n        let separatorValues;\r\n        if (separators === 'all') {\r\n            separatorValues = Array.from({ length: length - 1 }, (_, i) => i + 1);\r\n        }\r\n        else if (Array.isArray(separators)) {\r\n            separatorValues = separators;\r\n        }\r\n        else {\r\n            separatorValues = separators\r\n                .split(',')\r\n                .map((pos) => parseInt(pos, 10))\r\n                .filter((pos) => !isNaN(pos));\r\n        }\r\n        // Check for duplicate separator positions\r\n        const duplicates = separatorValues.filter((pos, index) => separatorValues.indexOf(pos) !== index);\r\n        if (duplicates.length > 0) {\r\n            printIonWarning(`[ion-input-otp] - Duplicate separator positions are not allowed. Received: ${separators}`, this.el);\r\n        }\r\n        const invalidSeparators = separatorValues.filter((pos) => pos > length);\r\n        if (invalidSeparators.length > 0) {\r\n            printIonWarning(`[ion-input-otp] - The following separator positions are greater than the input length (${length}): ${invalidSeparators.join(', ')}. These separators will be ignored.`, this.el);\r\n        }\r\n        this.parsedSeparators = separatorValues.filter((pos) => pos <= length);\r\n    }\r\n    componentWillLoad() {\r\n        this.inheritedAttributes = inheritAriaAttributes(this.el);\r\n        this.processSeparators();\r\n        this.initializeValues();\r\n    }\r\n    componentDidLoad() {\r\n        this.updateTabIndexes();\r\n    }\r\n    /**\r\n     * Get the regex pattern for allowed characters.\r\n     * If a pattern is provided, use it to create a regex pattern\r\n     * Otherwise, use the default regex pattern based on type\r\n     */\r\n    get validKeyPattern() {\r\n        return new RegExp(`^${this.getPattern()}$`, 'u');\r\n    }\r\n    /**\r\n     * Gets the string pattern to pass to the input element\r\n     * and use in the regex for allowed characters.\r\n     */\r\n    getPattern() {\r\n        const { pattern, type } = this;\r\n        if (pattern) {\r\n            return pattern;\r\n        }\r\n        return type === 'number' ? '[\\\\p{N}]' : '[\\\\p{L}\\\\p{N}]';\r\n    }\r\n    /**\r\n     * Get the default value for inputmode.\r\n     * If inputmode is provided, use it.\r\n     * Otherwise, use the default inputmode based on type\r\n     */\r\n    getInputmode() {\r\n        const { inputmode } = this;\r\n        if (inputmode) {\r\n            return inputmode;\r\n        }\r\n        if (this.type == 'number') {\r\n            return 'numeric';\r\n        }\r\n        else {\r\n            return 'text';\r\n        }\r\n    }\r\n    /**\r\n     * Initializes the input values array based on the current value prop.\r\n     * This splits the value into individual characters and validates them against\r\n     * the allowed pattern. The values are then used as the values in the native\r\n     * input boxes and the value of the input group is updated.\r\n     */\r\n    initializeValues() {\r\n        // Clear all input values\r\n        this.inputValues = Array(this.length).fill('');\r\n        // If the value is null, undefined, or an empty string, return\r\n        if (this.value == null || String(this.value).length === 0) {\r\n            return;\r\n        }\r\n        // Split the value into individual characters and validate\r\n        // them against the allowed pattern\r\n        const chars = String(this.value).split('').slice(0, this.length);\r\n        chars.forEach((char, index) => {\r\n            if (this.validKeyPattern.test(char)) {\r\n                this.inputValues[index] = char;\r\n            }\r\n        });\r\n        // Update the value without emitting events\r\n        this.value = this.inputValues.join('');\r\n        this.previousInputValues = [...this.inputValues];\r\n    }\r\n    /**\r\n     * Updates the value of the input group.\r\n     * This updates the value of the input group and emits an `ionChange` event.\r\n     * If all of the input boxes are filled, it emits an `ionComplete` event.\r\n     */\r\n    updateValue(event) {\r\n        const { inputValues, length } = this;\r\n        const newValue = inputValues.join('');\r\n        this.value = newValue;\r\n        this.emitIonInput(event);\r\n        if (newValue.length === length) {\r\n            this.ionComplete.emit({ value: newValue });\r\n        }\r\n    }\r\n    /**\r\n     * Emits an `ionChange` event.\r\n     * This API should be called for user committed changes.\r\n     * This API should not be used for external value changes.\r\n     */\r\n    emitIonChange(event) {\r\n        const { value } = this;\r\n        // Checks for both null and undefined values\r\n        const newValue = value == null ? value : value.toString();\r\n        this.ionChange.emit({ value: newValue, event });\r\n    }\r\n    /**\r\n     * Emits an `ionInput` event.\r\n     * This is used to emit the input value when the user types,\r\n     * backspaces, or pastes.\r\n     */\r\n    emitIonInput(event) {\r\n        const { value } = this;\r\n        // Checks for both null and undefined values\r\n        const newValue = value == null ? value : value.toString();\r\n        this.ionInput.emit({ value: newValue, event });\r\n    }\r\n    /**\r\n     * Focuses the next input box.\r\n     */\r\n    focusNext(currentIndex) {\r\n        var _a;\r\n        const { inputRefs, length } = this;\r\n        if (currentIndex < length - 1) {\r\n            (_a = inputRefs[currentIndex + 1]) === null || _a === void 0 ? void 0 : _a.focus();\r\n        }\r\n    }\r\n    /**\r\n     * Focuses the previous input box.\r\n     */\r\n    focusPrevious(currentIndex) {\r\n        var _a;\r\n        const { inputRefs } = this;\r\n        if (currentIndex > 0) {\r\n            (_a = inputRefs[currentIndex - 1]) === null || _a === void 0 ? void 0 : _a.focus();\r\n        }\r\n    }\r\n    /**\r\n     * Searches through the input values and returns the index\r\n     * of the first empty input.\r\n     * Returns -1 if all inputs are filled.\r\n     */\r\n    getFirstEmptyIndex() {\r\n        var _a;\r\n        const { inputValues, length } = this;\r\n        // Create an array of the same length as the input OTP\r\n        // and fill it with the input values\r\n        const values = Array.from({ length }, (_, i) => inputValues[i] || '');\r\n        return (_a = values.findIndex((value) => !value || value === '')) !== null && _a !== void 0 ? _a : -1;\r\n    }\r\n    /**\r\n     * Returns the index of the input that should be tabbed to.\r\n     * If all inputs are filled, returns the last input's index.\r\n     * Otherwise, returns the index of the first empty input.\r\n     */\r\n    getTabbableIndex() {\r\n        const { length } = this;\r\n        const firstEmptyIndex = this.getFirstEmptyIndex();\r\n        return firstEmptyIndex === -1 ? length - 1 : firstEmptyIndex;\r\n    }\r\n    /**\r\n     * Updates the tabIndexes for the input boxes.\r\n     * This is used to ensure that the correct input is\r\n     * focused when the user navigates using the tab key.\r\n     */\r\n    updateTabIndexes() {\r\n        const { inputRefs, inputValues, length } = this;\r\n        // Find first empty index after any filled boxes\r\n        let firstEmptyIndex = -1;\r\n        for (let i = 0; i < length; i++) {\r\n            if (!inputValues[i] || inputValues[i] === '') {\r\n                firstEmptyIndex = i;\r\n                break;\r\n            }\r\n        }\r\n        // Update tabIndex and aria-hidden for all inputs\r\n        inputRefs.forEach((input, index) => {\r\n            const shouldBeTabbable = firstEmptyIndex === -1 ? index === length - 1 : firstEmptyIndex === index;\r\n            input.tabIndex = shouldBeTabbable ? 0 : -1;\r\n            // If the input is empty and not the first empty input,\r\n            // it should be hidden from screen readers.\r\n            const isEmpty = !inputValues[index] || inputValues[index] === '';\r\n            input.setAttribute('aria-hidden', isEmpty && !shouldBeTabbable ? 'true' : 'false');\r\n        });\r\n    }\r\n    /**\r\n     * Determines if a separator should be shown for a given index by\r\n     * checking if the index is included in the parsed separators array.\r\n     */\r\n    showSeparator(index) {\r\n        const { length } = this;\r\n        return this.parsedSeparators.includes(index + 1) && index < length - 1;\r\n    }\r\n    render() {\r\n        var _a, _b;\r\n        const { autocapitalize, color, disabled, el, fill, hasFocus, inheritedAttributes, inputId, inputRefs, inputValues, length, readonly, shape, size, } = this;\r\n        const mode = getIonMode(this);\r\n        const inputmode = this.getInputmode();\r\n        const tabbableIndex = this.getTabbableIndex();\r\n        const pattern = this.getPattern();\r\n        const hasDescription = ((_b = (_a = el.querySelector('.input-otp-description')) === null || _a === void 0 ? void 0 : _a.textContent) === null || _b === void 0 ? void 0 : _b.trim()) !== '';\r\n        return (h(Host, { key: 'f15a29fb17b681ef55885ca36d3d5f899cbaca83', class: createColorClasses(color, {\r\n                [mode]: true,\r\n                'has-focus': hasFocus,\r\n                [`input-otp-size-${size}`]: true,\r\n                [`input-otp-shape-${shape}`]: true,\r\n                [`input-otp-fill-${fill}`]: true,\r\n                'input-otp-disabled': disabled,\r\n                'input-otp-readonly': readonly,\r\n            }) }, h(\"div\", Object.assign({ key: 'd7e1d4edd8aafcf2ed4313301287282e90fc7e82', role: \"group\", \"aria-label\": \"One-time password input\", class: \"input-otp-group\" }, inheritedAttributes), Array.from({ length }).map((_, index) => (h(Fragment, null, h(\"div\", { class: \"native-wrapper\" }, h(\"input\", { class: \"native-input\", id: `${inputId}-${index}`, \"aria-label\": `Input ${index + 1} of ${length}`, type: \"text\", autoCapitalize: autocapitalize, inputmode: inputmode, pattern: pattern, disabled: disabled, readOnly: readonly, tabIndex: index === tabbableIndex ? 0 : -1, value: inputValues[index] || '', autocomplete: \"one-time-code\", ref: (el) => (inputRefs[index] = el), onInput: this.onInput(index), onBlur: this.onBlur, onFocus: this.onFocus(index), onKeyDown: this.onKeyDown(index), onPaste: this.onPaste })), this.showSeparator(index) && h(\"div\", { class: \"input-otp-separator\" }))))), h(\"div\", { key: '3724a3159d02860971879a906092f9965f5a7c47', class: {\r\n                'input-otp-description': true,\r\n                'input-otp-description-hidden': !hasDescription,\r\n            } }, h(\"slot\", { key: '11baa2624926a08274508afe0833d9237a8dc35c' }))));\r\n    }\r\n    get el() { return getElement(this); }\r\n    static get watchers() { return {\r\n        \"value\": [\"valueChanged\"],\r\n        \"separators\": [\"processSeparators\"],\r\n        \"length\": [\"processSeparators\"]\r\n    }; }\r\n};\r\nlet inputIds = 0;\r\nInputOTP.style = {\r\n    ios: inputOtpIosCss,\r\n    md: inputOtpMdCss\r\n};\r\n\r\nexport { InputOTP as ion_input_otp };\r\n"],
  "mappings": "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",
  "names": ["input", "_a", "newChar", "el"]
}
