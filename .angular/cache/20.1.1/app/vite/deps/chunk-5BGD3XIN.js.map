{
  "version": 3,
  "sources": ["../../../../../../node_modules/@ionic/core/dist/esm/notch-controller-C5LPspO8.js"],
  "sourcesContent": ["/*!\r\n * (C) Ionic http://ionicframework.com - MIT License\r\n */\r\nimport { w as win } from './index-ZjP4CjeZ.js';\r\nimport { r as raf } from './helpers-1O4D2b7y.js';\r\n\r\n/**\r\n * A utility to calculate the size of an outline notch\r\n * width relative to the content passed. This is used in\r\n * components such as `ion-select` with `fill=\"outline\"`\r\n * where we need to pass slotted HTML content. This is not\r\n * needed when rendering plaintext content because we can\r\n * render the plaintext again hidden with `opacity: 0` inside\r\n * of the notch. As a result we can rely on the intrinsic size\r\n * of the element to correctly compute the notch width. We\r\n * cannot do this with slotted content because we cannot project\r\n * it into 2 places at once.\r\n *\r\n * @internal\r\n * @param el: The host element\r\n * @param getNotchSpacerEl: A function that returns a reference to the notch spacer element inside of the component template.\r\n * @param getLabelSlot: A function that returns a reference to the slotted content.\r\n */\r\nconst createNotchController = (el, getNotchSpacerEl, getLabelSlot) => {\r\n    let notchVisibilityIO;\r\n    const needsExplicitNotchWidth = () => {\r\n        const notchSpacerEl = getNotchSpacerEl();\r\n        if (\r\n        /**\r\n         * If the notch is not being used\r\n         * then we do not need to set the notch width.\r\n         */\r\n        notchSpacerEl === undefined ||\r\n            /**\r\n             * If either the label property is being\r\n             * used or the label slot is not defined,\r\n             * then we do not need to estimate the notch width.\r\n             */\r\n            el.label !== undefined ||\r\n            getLabelSlot() === null) {\r\n            return false;\r\n        }\r\n        return true;\r\n    };\r\n    const calculateNotchWidth = () => {\r\n        if (needsExplicitNotchWidth()) {\r\n            /**\r\n             * Run this the frame after\r\n             * the browser has re-painted the host element.\r\n             * Otherwise, the label element may have a width\r\n             * of 0 and the IntersectionObserver will be used.\r\n             */\r\n            raf(() => {\r\n                setNotchWidth();\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * When using a label prop we can render\r\n     * the label value inside of the notch and\r\n     * let the browser calculate the size of the notch.\r\n     * However, we cannot render the label slot in multiple\r\n     * places so we need to manually calculate the notch dimension\r\n     * based on the size of the slotted content.\r\n     *\r\n     * This function should only be used to set the notch width\r\n     * on slotted label content. The notch width for label prop\r\n     * content is automatically calculated based on the\r\n     * intrinsic size of the label text.\r\n     */\r\n    const setNotchWidth = () => {\r\n        const notchSpacerEl = getNotchSpacerEl();\r\n        if (notchSpacerEl === undefined) {\r\n            return;\r\n        }\r\n        if (!needsExplicitNotchWidth()) {\r\n            notchSpacerEl.style.removeProperty('width');\r\n            return;\r\n        }\r\n        const width = getLabelSlot().scrollWidth;\r\n        if (\r\n        /**\r\n         * If the computed width of the label is 0\r\n         * and notchSpacerEl's offsetParent is null\r\n         * then that means the element is hidden.\r\n         * As a result, we need to wait for the element\r\n         * to become visible before setting the notch width.\r\n         *\r\n         * We do not check el.offsetParent because\r\n         * that can be null if the host element has\r\n         * position: fixed applied to it.\r\n         * notchSpacerEl does not have position: fixed.\r\n         */\r\n        width === 0 &&\r\n            notchSpacerEl.offsetParent === null &&\r\n            win !== undefined &&\r\n            'IntersectionObserver' in win) {\r\n            /**\r\n             * If there is an IO already attached\r\n             * then that will update the notch\r\n             * once the element becomes visible.\r\n             * As a result, there is no need to create\r\n             * another one.\r\n             */\r\n            if (notchVisibilityIO !== undefined) {\r\n                return;\r\n            }\r\n            const io = (notchVisibilityIO = new IntersectionObserver((ev) => {\r\n                /**\r\n                 * If the element is visible then we\r\n                 * can try setting the notch width again.\r\n                 */\r\n                if (ev[0].intersectionRatio === 1) {\r\n                    setNotchWidth();\r\n                    io.disconnect();\r\n                    notchVisibilityIO = undefined;\r\n                }\r\n            }, \r\n            /**\r\n             * Set the root to be the host element\r\n             * This causes the IO callback\r\n             * to be fired in WebKit as soon as the element\r\n             * is visible. If we used the default root value\r\n             * then WebKit would only fire the IO callback\r\n             * after any animations (such as a modal transition)\r\n             * finished, and there would potentially be a flicker.\r\n             */\r\n            { threshold: 0.01, root: el }));\r\n            io.observe(notchSpacerEl);\r\n            return;\r\n        }\r\n        /**\r\n         * If the element is visible then we can set the notch width.\r\n         * The notch is only visible when the label is scaled,\r\n         * which is why we multiply the width by 0.75 as this is\r\n         * the same amount the label element is scaled by in the host CSS.\r\n         * (See $form-control-label-stacked-scale in ionic.globals.scss).\r\n         */\r\n        notchSpacerEl.style.setProperty('width', `${width * 0.75}px`);\r\n    };\r\n    const destroy = () => {\r\n        if (notchVisibilityIO) {\r\n            notchVisibilityIO.disconnect();\r\n            notchVisibilityIO = undefined;\r\n        }\r\n    };\r\n    return {\r\n        calculateNotchWidth,\r\n        destroy,\r\n    };\r\n};\r\n\r\nexport { createNotchController as c };\r\n"],
  "mappings": ";;;;;;;;AAuBA,IAAM,wBAAwB,CAAC,IAAI,kBAAkB,iBAAiB;AAClE,MAAI;AACJ,QAAM,0BAA0B,MAAM;AAClC,UAAM,gBAAgB,iBAAiB;AACvC;AAAA;AAAA;AAAA;AAAA;AAAA,MAKA,kBAAkB;AAAA;AAAA;AAAA;AAAA;AAAA,MAMd,GAAG,UAAU,UACb,aAAa,MAAM;AAAA,MAAM;AACzB,aAAO;AAAA,IACX;AACA,WAAO;AAAA,EACX;AACA,QAAM,sBAAsB,MAAM;AAC9B,QAAI,wBAAwB,GAAG;AAO3B,UAAI,MAAM;AACN,sBAAc;AAAA,MAClB,CAAC;AAAA,IACL;AAAA,EACJ;AAcA,QAAM,gBAAgB,MAAM;AACxB,UAAM,gBAAgB,iBAAiB;AACvC,QAAI,kBAAkB,QAAW;AAC7B;AAAA,IACJ;AACA,QAAI,CAAC,wBAAwB,GAAG;AAC5B,oBAAc,MAAM,eAAe,OAAO;AAC1C;AAAA,IACJ;AACA,UAAM,QAAQ,aAAa,EAAE;AAC7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAaA,UAAU,KACN,cAAc,iBAAiB,QAC/B,QAAQ,UACR,0BAA0B;AAAA,MAAK;AAQ/B,UAAI,sBAAsB,QAAW;AACjC;AAAA,MACJ;AACA,YAAM,KAAM,oBAAoB,IAAI;AAAA,QAAqB,CAAC,OAAO;AAK7D,cAAI,GAAG,CAAC,EAAE,sBAAsB,GAAG;AAC/B,0BAAc;AACd,eAAG,WAAW;AACd,gCAAoB;AAAA,UACxB;AAAA,QACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QAUA,EAAE,WAAW,MAAM,MAAM,GAAG;AAAA,MAAC;AAC7B,SAAG,QAAQ,aAAa;AACxB;AAAA,IACJ;AAQA,kBAAc,MAAM,YAAY,SAAS,GAAG,QAAQ,IAAI,IAAI;AAAA,EAChE;AACA,QAAM,UAAU,MAAM;AAClB,QAAI,mBAAmB;AACnB,wBAAkB,WAAW;AAC7B,0BAAoB;AAAA,IACxB;AAAA,EACJ;AACA,SAAO;AAAA,IACH;AAAA,IACA;AAAA,EACJ;AACJ;",
  "names": []
}
