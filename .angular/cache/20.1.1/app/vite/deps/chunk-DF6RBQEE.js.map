{
  "version": 3,
  "sources": ["../../../../../../node_modules/@ionic/core/dist/esm/input.utils-zWijNCrx.js"],
  "sourcesContent": ["/*!\r\n * (C) Ionic http://ionicframework.com - MIT License\r\n */\r\nimport { w as win } from './index-ZjP4CjeZ.js';\r\nimport { r as raf } from './helpers-1O4D2b7y.js';\r\nimport { o as printIonError } from './index-B_U9CtaY.js';\r\n\r\n/**\r\n * Used to update a scoped component that uses emulated slots. This fires when\r\n * content is passed into the slot or when the content inside of a slot changes.\r\n * This is not needed for components using native slots in the Shadow DOM.\r\n * @internal\r\n * @param el The host element to observe\r\n * @param slotName mutationCallback will fire when nodes on these slot(s) change\r\n * @param mutationCallback The callback to fire whenever the slotted content changes\r\n */\r\nconst createSlotMutationController = (el, slotName, mutationCallback) => {\r\n    let hostMutationObserver;\r\n    let slottedContentMutationObserver;\r\n    if (win !== undefined && 'MutationObserver' in win) {\r\n        const slots = Array.isArray(slotName) ? slotName : [slotName];\r\n        hostMutationObserver = new MutationObserver((entries) => {\r\n            for (const entry of entries) {\r\n                for (const node of entry.addedNodes) {\r\n                    /**\r\n                     * Check to see if the added node\r\n                     *  is our slotted content.\r\n                     */\r\n                    if (node.nodeType === Node.ELEMENT_NODE && slots.includes(node.slot)) {\r\n                        /**\r\n                         * If so, we want to watch the slotted\r\n                         * content itself for changes. This lets us\r\n                         * detect when content inside of the slot changes.\r\n                         */\r\n                        mutationCallback();\r\n                        /**\r\n                         * Adding the listener in an raf\r\n                         * waits until Stencil moves the slotted element\r\n                         * into the correct place in the event that\r\n                         * slotted content is being added.\r\n                         */\r\n                        raf(() => watchForSlotChange(node));\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        hostMutationObserver.observe(el, {\r\n            childList: true,\r\n            /**\r\n             * This fixes an issue with the `ion-input` and\r\n             * `ion-textarea` not re-rendering in some cases\r\n             * when using the label slot functionality.\r\n             *\r\n             * HTML element patches in Stencil that are enabled\r\n             * by the `experimentalSlotFixes` flag in Stencil v4\r\n             * result in DOM manipulations that won't trigger\r\n             * the current mutation observer configuration and\r\n             * callback.\r\n             */\r\n            subtree: true,\r\n        });\r\n    }\r\n    /**\r\n     * Listen for changes inside of the slotted content.\r\n     * We can listen for subtree changes here to be\r\n     * informed of text within the slotted content\r\n     * changing. Doing this on the host is possible\r\n     * but it is much more expensive to do because\r\n     * it also listens for changes to the internals\r\n     * of the component.\r\n     */\r\n    const watchForSlotChange = (slottedEl) => {\r\n        var _a;\r\n        if (slottedContentMutationObserver) {\r\n            slottedContentMutationObserver.disconnect();\r\n            slottedContentMutationObserver = undefined;\r\n        }\r\n        slottedContentMutationObserver = new MutationObserver((entries) => {\r\n            mutationCallback();\r\n            for (const entry of entries) {\r\n                for (const node of entry.removedNodes) {\r\n                    /**\r\n                     * If the element was removed then we\r\n                     * need to destroy the MutationObserver\r\n                     * so the element can be garbage collected.\r\n                     */\r\n                    if (node.nodeType === Node.ELEMENT_NODE && node.slot === slotName) {\r\n                        destroySlottedContentObserver();\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        /**\r\n         * Listen for changes inside of the element\r\n         * as well as anything deep in the tree.\r\n         * We listen on the parentElement so that we can\r\n         * detect when slotted element itself is removed.\r\n         */\r\n        slottedContentMutationObserver.observe((_a = slottedEl.parentElement) !== null && _a !== void 0 ? _a : slottedEl, { subtree: true, childList: true });\r\n    };\r\n    const destroy = () => {\r\n        if (hostMutationObserver) {\r\n            hostMutationObserver.disconnect();\r\n            hostMutationObserver = undefined;\r\n        }\r\n        destroySlottedContentObserver();\r\n    };\r\n    const destroySlottedContentObserver = () => {\r\n        if (slottedContentMutationObserver) {\r\n            slottedContentMutationObserver.disconnect();\r\n            slottedContentMutationObserver = undefined;\r\n        }\r\n    };\r\n    return {\r\n        destroy,\r\n    };\r\n};\r\n\r\nconst getCounterText = (value, maxLength, counterFormatter) => {\r\n    const valueLength = value == null ? 0 : value.toString().length;\r\n    const defaultCounterText = defaultCounterFormatter(valueLength, maxLength);\r\n    /**\r\n     * If developers did not pass a custom formatter,\r\n     * use the default one.\r\n     */\r\n    if (counterFormatter === undefined) {\r\n        return defaultCounterText;\r\n    }\r\n    /**\r\n     * Otherwise, try to use the custom formatter\r\n     * and fallback to the default formatter if\r\n     * there was an error.\r\n     */\r\n    try {\r\n        return counterFormatter(valueLength, maxLength);\r\n    }\r\n    catch (e) {\r\n        printIonError('[ion-input] - Exception in provided `counterFormatter`:', e);\r\n        return defaultCounterText;\r\n    }\r\n};\r\nconst defaultCounterFormatter = (length, maxlength) => {\r\n    return `${length} / ${maxlength}`;\r\n};\r\n\r\nexport { createSlotMutationController as c, getCounterText as g };\r\n"],
  "mappings": ";;;;;;;;;;;AAgBA,IAAM,+BAA+B,CAAC,IAAI,UAAU,qBAAqB;AACrE,MAAI;AACJ,MAAI;AACJ,MAAI,QAAQ,UAAa,sBAAsB,KAAK;AAChD,UAAM,QAAQ,MAAM,QAAQ,QAAQ,IAAI,WAAW,CAAC,QAAQ;AAC5D,2BAAuB,IAAI,iBAAiB,CAAC,YAAY;AACrD,iBAAW,SAAS,SAAS;AACzB,mBAAW,QAAQ,MAAM,YAAY;AAKjC,cAAI,KAAK,aAAa,KAAK,gBAAgB,MAAM,SAAS,KAAK,IAAI,GAAG;AAMlE,6BAAiB;AAOjB,gBAAI,MAAM,mBAAmB,IAAI,CAAC;AAClC;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ,CAAC;AACD,yBAAqB,QAAQ,IAAI;AAAA,MAC7B,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAYX,SAAS;AAAA,IACb,CAAC;AAAA,EACL;AAUA,QAAM,qBAAqB,CAAC,cAAc;AACtC,QAAI;AACJ,QAAI,gCAAgC;AAChC,qCAA+B,WAAW;AAC1C,uCAAiC;AAAA,IACrC;AACA,qCAAiC,IAAI,iBAAiB,CAAC,YAAY;AAC/D,uBAAiB;AACjB,iBAAW,SAAS,SAAS;AACzB,mBAAW,QAAQ,MAAM,cAAc;AAMnC,cAAI,KAAK,aAAa,KAAK,gBAAgB,KAAK,SAAS,UAAU;AAC/D,0CAA8B;AAAA,UAClC;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ,CAAC;AAOD,mCAA+B,SAAS,KAAK,UAAU,mBAAmB,QAAQ,OAAO,SAAS,KAAK,WAAW,EAAE,SAAS,MAAM,WAAW,KAAK,CAAC;AAAA,EACxJ;AACA,QAAM,UAAU,MAAM;AAClB,QAAI,sBAAsB;AACtB,2BAAqB,WAAW;AAChC,6BAAuB;AAAA,IAC3B;AACA,kCAA8B;AAAA,EAClC;AACA,QAAM,gCAAgC,MAAM;AACxC,QAAI,gCAAgC;AAChC,qCAA+B,WAAW;AAC1C,uCAAiC;AAAA,IACrC;AAAA,EACJ;AACA,SAAO;AAAA,IACH;AAAA,EACJ;AACJ;AAEA,IAAM,iBAAiB,CAAC,OAAO,WAAW,qBAAqB;AAC3D,QAAM,cAAc,SAAS,OAAO,IAAI,MAAM,SAAS,EAAE;AACzD,QAAM,qBAAqB,wBAAwB,aAAa,SAAS;AAKzE,MAAI,qBAAqB,QAAW;AAChC,WAAO;AAAA,EACX;AAMA,MAAI;AACA,WAAO,iBAAiB,aAAa,SAAS;AAAA,EAClD,SACO,GAAG;AACN,kBAAc,2DAA2D,CAAC;AAC1E,WAAO;AAAA,EACX;AACJ;AACA,IAAM,0BAA0B,CAAC,QAAQ,cAAc;AACnD,SAAO,GAAG,MAAM,MAAM,SAAS;AACnC;",
  "names": []
}
